Language Documentation
======================

### Overview

The Hotel Management DSL is a domain-specific language designed for managing hotel reservations and related services. This documentation provides details about the language syntax, semantics and  usage.

### Syntax

The language consists of various nodes, each representing a specific operation:

#### Reservation Node:

RESERVATION <RoomType> <CheckInDate> <CheckOutDate> <GuestName>

#### Update Node:

UPDATE <ReservationID> <Attribute> <NewValue>

#### Cancel Node:

CANCEL <ReservationID>

#### Check Node:

CHECK <ReservationID>

#### Create Guest Profile Node:

CREATE_GUEST_PROFILE <GuestName> <GuestContact>

#### Generate Invoice Node:

GENERATE_INVOICE <ReservationID>

#### Request Service Node:

REQUEST_SERVICE <ServiceName> <ReservationID>

### Semantics

The interpreter processes an Abstract Syntax Tree (AST) constructed from the input program. It executes each node in the AST based on its type. Semantics for each node type:

#### Reservation Node:

Creates a new reservation with the specified room type, check-in and check-out dates, and guest name.

#### Update Node:

Updates the attribute of a reservation with the specified reservation ID to the new value.

#### Cancel Node:

Cancels the reservation identified by the reservation ID.

#### Create Guest Profile Node:

Creates a new guest profile with the specified guest name and contact information.

#### Generate Invoice Node:

Generates an invoice for the reservation identified by the reservation ID.

#### Request Service Node:

Requests a service for the reservation identified by the reservation ID.

### Usage

Example program:

RESERVATION "Standard" "2023-01-01" "2023-01-05" "John Doe" UPDATE "123456" "RoomType""Deluxe" CANCEL "123456" CREATE_GUEST_PROFILE "Alice Johnson" "alice@example.com"GENERATE_INVOICE "789012" REQUEST_SERVICE "RoomService" "789012"


Lexer Documentation
-------------------

### Overview

The lexer is a crucial component of the Hotel Management DSL compiler, responsible for analyzing the input source code and breaking it down into a sequence of tokens.

### Keywords

Recognized keywords:

-   reserve

-   update

-   cancel

-   check

-   create

-   generate

-   request

### Token Types

The lexer identifies the following token types:

-   Symbol Token (TOKEN_SYMBOL)

-   Keyword Token (TOKEN_KEYWORD)

-   Identifier Token (TOKEN_IDENTIFIER)

-   Literal Token (TOKEN_LITERAL)

-   End-of-File Token (TOKEN_EOF)

### Functions

-   isKeyword: Checks if a given string is a keyword in the language.

-   getNextToken: Retrieves the next token from the input source code.

### Token Recognition

-   Symbols: Recognizes symbols such as ,, :, ;, (, ), +, -, *, /.

-   Keywords and Identifiers: Recognizes keywords based on predefined keywords in the language. Identifiers are sequences of alphabetic characters.

-   Literals: Numeric literals consist of consecutive digits. String literals are enclosed in either double (") or single (') quotes.

-   End of File: Detects the end of the input source code.

### Usage

Integrate the lexer into your compiler or interpreter pipeline to tokenize the input source code before further processing.
The lexer employs a simple state machine to recognize different token types and skips whitespaces. It supports symbols, keywords, identifiers, and basic literals (numeric and string literals).
Example:
Input: reserve Standard "2023-01-01" "2023-01-05" "John Doe"

Tokens:

-   Keyword: reserve

-   Identifier: Standard

-   Literal (String): "2023-01-01"

-   Literal (String): "2023-01-05"

-   Literal (String): "John Doe"

Parser Documentation
--------------------

### Overview

The parser is responsible for analyzing the sequence of tokens generated by the lexer and constructing an Abstract Syntax Tree (AST).

### Node Structures

-   Reservation Node (ReservationNode)

-   Update Node (UpdateNode)

-   Cancel Node (CancelNode)

-   Check Node (CheckNode)

-   Create Guest Profile Node (CreateGuestProfileNode)

-   Generate Invoice Node (GenerateInvoiceNode)

-   Request Service Node (RequestServiceNode)

-   Base AST Node (ASTNode)

### Parsing Functions

Parsing functions for each type of operation in the Hotel Management DSL:

-   parseReservation

-   parseUpdate

-   parseCancel

-   parseCheck

-   parseCreateGuestProfile

-   parseGenerateInvoice

-   parseRequestService

-   parseStatement: Determines the type of operation based on the first keyword encountered and calls the corresponding specialized parsing function.

### Memory Management

The parser manages memory for dynamically allocated structures, freeing allocated memory in case of parsing errors or completion.

### Usage

To use the parser, integrate it with the lexer and call the appropriate parsing function based on the input source code. Handle the resulting AST for further processing in the compilation or interpretation pipeline.

### Error Handling

Parsing functions return NULL in case of syntax errors or other issues. Ensure proper error handling is implemented in the calling code.


Example Main Function: Integration of Parser and Interpreter
------------------------------------------------------------

Example: Hard-coded input string representing a command in your languageconst char *input = "reserve room deluxe from 2023-01-01 to 2023-01-05 for John Doe"; // Parse the input to create an AST ASTNode *parsedTree = parseStatement(&input); if(parsedTree != NULL) { printf("Parsing successful!\n"); // Execute the parsed programexecuteProgram(parsedTree); // freeAST(parsedTree); } else {printf("Parsing failed.\n"); } return 0; }

